$(eval $(call IncludeCustomExtension, hotspot/lib/JvmOverrideFiles.gmk))

################################################################################
# This file contains explicit overrides of CFLAGS and/or precompiled header
# status for individual files on specific platforms.

ifeq ($(TOOLCHAIN_TYPE), gcc)
  BUILD_LIBJVM_vmStructs.cpp_CXXFLAGS := -fno-var-tracking-assignments
  BUILD_LIBJVM_jvmciCompilerToVM.cpp_CXXFLAGS := -fno-var-tracking-assignments
  BUILD_LIBJVM_jvmciCompilerToVMInit.cpp_CXXFLAGS := -fno-var-tracking-assignments
  BUILD_LIBJVM_assembler_x86.cpp_CXXFLAGS := -Wno-maybe-uninitialized
  BUILD_LIBJVM_cardTableBarrierSetAssembler_x86.cpp_CXXFLAGS := -Wno-maybe-uninitialized
  BUILD_LIBJVM_interp_masm_x86.cpp_CXXFLAGS := -Wno-uninitialized
endif

LIBJVM_FDLIBM_COPY_OPT_FLAG := $(CXX_O_FLAG_NONE)
# If the FDLIBM_CFLAGS variable is non-empty we know
# that the fdlibm-fork in hotspot can get optimized
# by using -ffp-contract=off on GCC/Clang platforms.
ifneq ($(FDLIBM_CFLAGS), )
  LIBJVM_FDLIBM_COPY_OPT_FLAG := $(CXX_O_FLAG_NORM)
endif

ifeq ($(OPENJDK_TARGET_OS), linux)
  BUILD_LIBJVM_ostream.cpp_CXXFLAGS := -D_FILE_OFFSET_BITS=64
  BUILD_LIBJVM_logFileOutput.cpp_CXXFLAGS := -D_FILE_OFFSET_BITS=64

  BUILD_LIBJVM_sharedRuntimeTrig.cpp_CXXFLAGS := -DNO_PCH $(FDLIBM_CFLAGS) $(LIBJVM_FDLIBM_COPY_OPT_FLAG)
  BUILD_LIBJVM_sharedRuntimeTrans.cpp_CXXFLAGS := -DNO_PCH $(FDLIBM_CFLAGS) $(LIBJVM_FDLIBM_COPY_OPT_FLAG)

  ifeq ($(TOOLCHAIN_TYPE), clang)
    JVM_PRECOMPILED_HEADER_EXCLUDE := sharedRuntimeTrig.cpp sharedRuntimeTrans.cpp
  endif

  ifeq ($(OPENJDK_TARGET_CPU), x86)
    # Performance measurements show that by compiling GC related code, we could
    # significantly reduce the GC pause time on 32 bit Linux/Unix platforms by
    # compiling without the PIC flag (-fPIC on linux).
    # See 6454213 for more details.
    ALL_SRC := $(filter %.cpp, $(call CacheFind, $(TOPDIR)/src/hotspot/share))
    NONPIC_FILTER := $(addsuffix %, $(addprefix $(TOPDIR)/src/hotspot/share/, memory oops gc))
    # Due to what looks like a bug in the old build implementation of this, add a
    # couple of more files that were accidentally matched as substrings of GC related
    # files.
    NONPIC_SRC := $(filter $(NONPIC_FILTER), $(ALL_SRC)) globals.cpp location.cpp
    # Declare variables for each source file that needs the pic flag like this:
    # BUILD_JVM_<srcfile>_CXXFLAGS := -fno-PIC
    # This will get implicitly picked up by SetupNativeCompilation below.
    $(foreach s, $(NONPIC_SRC), $(eval BUILD_LIBJVM_$(notdir $s)_CXXFLAGS := -fno-PIC))
  endif

else ifeq ($(OPENJDK_TARGET_OS), macosx)
  # The copied fdlibm routines in these files must not be optimized
  BUILD_LIBJVM_sharedRuntimeTrig.cpp_CXXFLAGS := $(FDLIBM_CFLAGS) $(LIBJVM_FDLIBM_COPY_OPT_FLAG)
  BUILD_LIBJVM_sharedRuntimeTrans.cpp_CXXFLAGS := $(FDLIBM_CFLAGS) $(LIBJVM_FDLIBM_COPY_OPT_FLAG)
  ifeq ($(TOOLCHAIN_TYPE), clang)
    # NOTE: The old build tested clang version to make sure this workaround
    # for the clang bug was still needed.
    BUILD_LIBJVM_loopTransform.cpp_CXXFLAGS := $(CXX_O_FLAG_NONE)
    ifneq ($(DEBUG_LEVEL), slowdebug)
      BUILD_LIBJVM_unsafe.cpp_CXXFLAGS := -O1
    endif

    # The following files are compiled at various optimization
    # levels due to optimization issues encountered at the
    # default level. The Clang compiler issues a compile
    # time error if there is an optimization level specification
    # skew between the PCH file and the C++ file.  Especially if the
    # PCH file is compiled at a higher optimization level than
    # the C++ file.  One solution might be to prepare extra optimization
    # level specific PCH files for the opt build and use them here, but
    # it's probably not worth the effort as long as only a few files
    # need this special handling.
    JVM_PRECOMPILED_HEADER_EXCLUDE := sharedRuntimeTrig.cpp sharedRuntimeTrans.cpp loopTransform.cpp unsafe.cpp jvmciCompilerToVM.cpp
  endif

endif
