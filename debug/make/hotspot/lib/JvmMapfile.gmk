$(eval $(call IncludeCustomExtension, hotspot/lib/JvmMapfile.gmk))

################################################################################
# Combine a list of static symbols

ifneq ($(OPENJDK_TARGET_OS)-$(OPENJDK_TARGET_CPU), windows-x86_64)
  # On Windows x86_64, we should not have any symbols at all, since that
  # results in duplicate warnings from the linker (JDK-8043491).
  SYMBOLS_SRC += $(TOPDIR)/make/hotspot/symbols/symbols-shared
endif

ifeq ($(OPENJDK_TARGET_OS_TYPE), unix)
  SYMBOLS_SRC += $(TOPDIR)/make/hotspot/symbols/symbols-unix
endif

ifneq ($(wildcard $(TOPDIR)/make/hotspot/symbols/symbols-$(OPENJDK_TARGET_OS)), )
  SYMBOLS_SRC += $(TOPDIR)/make/hotspot/symbols/symbols-$(OPENJDK_TARGET_OS)
endif

ifneq ($(findstring debug, $(DEBUG_LEVEL)), )
  ifneq ($(wildcard $(TOPDIR)/make/hotspot/symbols/symbols-$(OPENJDK_TARGET_OS)-debug), )
    SYMBOLS_SRC += $(TOPDIR)/make/hotspot/symbols/symbols-$(OPENJDK_TARGET_OS)-debug
  endif
endif

################################################################################
# Create a dynamic list of symbols from the built object files. This is highly
# platform dependent.

ifeq ($(OPENJDK_TARGET_OS), linux)
  DUMP_SYMBOLS_CMD := $(NM) --defined-only *.o
  ifneq ($(FILTER_SYMBOLS_PATTERN), )
    FILTER_SYMBOLS_PATTERN := $(FILTER_SYMBOLS_PATTERN)|
  endif
  FILTER_SYMBOLS_PATTERN := $(FILTER_SYMBOLS_PATTERN)^_ZTV|^gHotSpotVM|^UseSharedSpaces$$
  FILTER_SYMBOLS_PATTERN := $(FILTER_SYMBOLS_PATTERN)|^_ZN9Arguments17SharedArchivePathE$$
  FILTER_SYMBOLS_AWK_SCRIPT := \
      '{ \
        if ($$3 ~ /$(FILTER_SYMBOLS_PATTERN)/) print $$3; \
      }'

else ifeq ($(OPENJDK_TARGET_OS), macosx)
  # nm on macosx prints out "warning: nm: no name list" to stderr for
  # files without symbols. Hide this, even at the expense of hiding real errors.
  DUMP_SYMBOLS_CMD := $(NM) -Uj *.o 2> /dev/null
  ifneq ($(FILTER_SYMBOLS_PATTERN), )
    FILTER_SYMBOLS_PATTERN := $(FILTER_SYMBOLS_PATTERN)|
  endif
  FILTER_SYMBOLS_PATTERN := $(FILTER_SYMBOLS_PATTERN)^_ZTV|^gHotSpotVM
  FILTER_SYMBOLS_AWK_SCRIPT := \
      '{ \
        if ($$3 ~ /$(FILTER_SYMBOLS_PATTERN)/) print $$3; \
      }'

else
  $(error Unknown target OS $(OPENJDK_TARGET_OS) in JvmMapfile.gmk)
endif

# A more correct solution would be to send BUILD_LIBJVM_ALL_OBJS instead of
# cd && *.o, but this will result in very long command lines, which is
# problematic on some platforms.
$(JVM_OUTPUTDIR)/symbols-objects: $(BUILD_LIBJVM_ALL_OBJS)
	$(call LogInfo, Generating symbol list from object files)
	$(CD) $(JVM_OUTPUTDIR)/objs && \
	  $(DUMP_SYMBOLS_CMD) | $(NAWK) $(FILTER_SYMBOLS_AWK_SCRIPT) | $(SORT) -u > $@

SYMBOLS_SRC += $(JVM_OUTPUTDIR)/symbols-objects

################################################################################
# Now concatenate all symbol lists into a single file and remove comments.

$(JVM_OUTPUTDIR)/symbols: $(SYMBOLS_SRC)
	$(SED) -e '/^#/d' $^ > $@

################################################################################
# Finally convert the symbol list into a platform-specific mapfile

ifeq ($(OPENJDK_TARGET_OS), macosx)
  # On macosx, we need to add a leading underscore
  define create-mapfile-work
	  $(AWK) '{ if ($$0 ~ ".") { print "  _" $$0 } }'  < $^ > $@.tmp
  endef
else
  # Assume standard linker script
  define create-mapfile-work
	  $(PRINTF) "SUNWprivate_1.1 { \n  global: \n" > $@.tmp
	  $(AWK) '{ if ($$0 ~ ".") { print "    " $$0 ";" } }' < $^ >> $@.tmp
	  $(PRINTF) "  local: \n    *; \n }; \n" >> $@.tmp
  endef
endif

define create-mapfile
	$(call LogInfo, Creating mapfile)
	$(call MakeDir, $(@D))
	$(call create-mapfile-work)
	$(RM) $@
	$(MV) $@.tmp $@
endef

$(JVM_MAPFILE): $(JVM_OUTPUTDIR)/symbols
	$(call create-mapfile)
